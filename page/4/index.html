<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qiweipeng.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="齐卫鹏的博客">
<meta property="og:url" content="https://qiweipeng.github.io/page/4/index.html">
<meta property="og:site_name" content="齐卫鹏的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="齐卫鹏">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qiweipeng.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>齐卫鹏的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">齐卫鹏的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2018/04/06/gitignore-ds_store/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/06/gitignore-ds_store/" class="post-title-link" itemprop="url">如何设置 Git 全局忽略 .DS_Store 文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-06 22:21:32" itemprop="dateCreated datePublished" datetime="2018-04-06T22:21:32+08:00">2018-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在家目录创建全局忽略文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .gitignore_global</span><br></pre></td></tr></table></figure>

<p>之后打开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim .gitignore_global</span><br></pre></td></tr></table></figure>

<p>写入要全局忽略的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">*/.DS_Store</span><br><span class="line">xcuserdata/</span><br></pre></td></tr></table></figure>

<p>之后打开家目录的 <code>.gitconfig</code> 文件，这是 Git 的全局配置文件，在里面填入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core] </span><br><span class="line">excludesfile = ~/.gitignore_global</span><br></pre></td></tr></table></figure>

<p>当然这一步我们也可以直接在命令行中操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.excludesfile ~/.gitignore_global</span><br></pre></td></tr></table></figure>

<p>之后，所有的 Git 项目都会忽略掉 <code>.DS_Store</code> 文件了。当然，全局忽略其它的文件也是一样的方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2018/04/06/git-ssh-key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/06/git-ssh-key/" class="post-title-link" itemprop="url">macOS 下 Git 多账号配置，同时管理多个 SSH Key</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-06 20:18:42" itemprop="dateCreated datePublished" datetime="2018-04-06T20:18:42+08:00">2018-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多人有这样的需求：不仅有 GitHub，还会在 BitBucket 上管理私有的代码库，同时可能因为访问国外服务器速度慢，还会在码云、Coding 上有自己的代码库。HTTPS 毕竟不如 SSH 来的方便和安全，于是我们就有了使用多对 SSH 密钥的需求。</p>
<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>先查看家目录是否有一个 <code>.ssh</code> 的目录，如果没有说明还没有任何 SSH 密钥，我们先输入如下命令生成密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;qiweipeng@hotmail.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/qiweipeng/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>这里让我们输入密钥保存的位置，如果直接回车，默认的保存位置就是家目录中的 <code>.ssh</code> 目录，默认名字是 <code>id_rsa</code>，由于我们需要为不同的网站设置不同的，所以我们自定义文件名 <code>id_rsa_github</code>，之后的密码可以不设置，我们两次回车：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/qiweipeng/.ssh/id_rsa):/Users/qiweipeng/.ssh/id_rsa_github</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in id_rsa_github.</span><br><span class="line">Your public key has been saved in id_rsa_github.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:SRqk4YpV6A2tWc1JZDLn5jJVycjYSpffl+0Y55v+meM qiweipeng@hotmail.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|   o=O*=..       |</span><br><span class="line">|  oo=XX.o        |</span><br><span class="line">| ..Boo=...   o   |</span><br><span class="line">| o+.o+ +... + o  |</span><br><span class="line">|. . o o S  . *   |</span><br><span class="line">|     o      . o  |</span><br><span class="line">|               o |</span><br><span class="line">|              o.o|</span><br><span class="line">|             .oEo|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>

<p>此时一对 SHH 密钥已经生成好了，他们分别是 <code>id_rsa_github</code> 和 <code>id_rsa_github.pub</code>，对应着私钥和公钥，位置就在我们指定的 <code>.ssh</code> 目录下。</p>
<p>之后，我们以同样方法再创建一对密钥，命名为 <code>id_rsa_bitbucket</code> 和 <code>id_rsa_bitbucket.pub</code>，这样，我们第一步生成密钥的工作就做完了。</p>
<h2 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h2><p>以 GitHub 为例，首先查看公钥然后复制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa_github.pub</span><br></pre></td></tr></table></figure>

<p>登陆 GitHub，在 <code>Settings - SSH and CPG keys</code> 的位置点击 <code>New SSH key</code>，然后粘贴公钥。</p>
<h2 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h2><p>此时我们仅仅创建了两对密钥，因此 <code>.ssh</code> 文件夹中也只有这两对密钥；我们在这个文件夹创建一个 <code>config</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch config</span><br></pre></td></tr></table></figure>

<p>之后打开填入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line">    User qiweipeng</span><br><span class="line"></span><br><span class="line"># bitbucket</span><br><span class="line">Host bitbucket.org</span><br><span class="line">    HostName bitbucket.org</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_bitbucket</span><br><span class="line">    User qiweipeng</span><br></pre></td></tr></table></figure>

<p>这里面重要的一个是 <code>HostName</code>，一定要填写正确，一个是 <code>IdentityFile</code> 就填写对应的私钥。</p>
<p>如果是码云，<code>HostName</code> 就是 <code>gitee.com</code>；如果是 Coding 呢 <code>HostName</code> 就是 <code>git.coding.net</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>同样以 GitHub 为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27;github.com (13.229.188.59)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;github.com,13.229.188.59&#x27; (RSA) to the list of known hosts.</span><br><span class="line">Hi qiweipeng! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>第一次链接需要确认一下，它给了一个 <code>RSA key fingerprint</code>，这是为了安全考虑，让你确认一下这个指纹是否是来自 GitHub 服务器的，我们可以对照<a target="_blank" rel="noopener" href="https://help.github.com/articles/github-s-ssh-key-fingerprints/">这里</a>查看，如果没问题就 <code>yes</code>，之后可以看到已经成功连接啦！</p>
<p>此时我们查看 <code>.ssh</code> 目录，可以看到，多了一个 <code>known_hosts</code> 文件，这是一个信任列表，又上面的命令也能看到 <code>Permanently added &#39;github.com,13.229.188.59&#39; (RSA) to the list of known hosts.</code></p>
<p>类似地，BitBucket、码云、Coding 的命令分别是 <code>git@bitbucket.org</code>、<code>git@gitee.com</code>、<code>git@git.coding.net</code>，不出意外，是可以测试成功的。</p>
<p>到此为止，我们就可以使用 Git 进行多账号操作了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2018/03/15/initialization-in-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/15/initialization-in-swift/" class="post-title-link" itemprop="url">Swift 的构造过程（Initialization）详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 23:07:29" itemprop="dateCreated datePublished" datetime="2018-03-15T23:07:29+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文基本涵盖 Swift 中关于构造器的所有基础知识点，错误难免，希望各位指正。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><blockquote>
<p>“Initialization is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use.”</p>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>
<p>这是官方的定义，从中可以看到：</p>
<ul>
<li>构造器可以使用的场景不仅仅是类，还可以是结构体和枚举（我们知道 Swift 中的结构体和枚举的强大已经不是 Objective-C 可以相比的了）；</li>
<li>实例在构造完成之前是无法使用的；</li>
<li>构造过程主要是包括存储型属性的赋初值的过程，另外还包括一些其他必须的设置和初始化工作；</li>
</ul>
<p>为了阅读的通畅，我们先展示类、结构体、枚举的构造过程，这样可以有一个初步的认识。之后再进一步深入。</p>
<h3 id="类的构造过程"><a href="#类的构造过程" class="headerlink" title="类的构造过程"></a>类的构造过程</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">id</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.id <span class="operator">=</span> id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Roger&quot;</span>, id: <span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里定义一个 <code>Person</code> 类，拥有两个属性，<code>name</code>（因为名字可以更改，所以是 <code>var</code>，又因为所有人都要有名字，所以是非可选型）和 <code>id</code>（ID 一般是无法更改的，所以是 <code>let</code>）。Swift 中的构造器没有返回值，在其中我们完成了两个属性的初始化。</p>
<blockquote>
<p>属性是可以赋默认值的，没有赋默认值的属性必须在构造器中完成初始化；赋默认值的属性如果没有在构造器中完成初始化，构造过程会用其默认值为其初始化。</p>
</blockquote>
<p>上面代码我们暂且让 <code>id</code> 可更改，我们为其设置一个默认值 <code>&quot;000000&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;000000&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Roger&quot;</span>)</span><br><span class="line">roger.id <span class="comment">// &quot;000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，构造过程中我们只初始化了一个属性，有默认值的属性如果在这个过程中没有被初始化，那么会自动通过默认值为其初始化。</p>
<blockquote>
<p>类只有一种情况下会提供默认的构造器，就是这个类的所有属性均存在默认值，并且还没有自定义构造器的情况，这个默认的构造器就是无参数的构造器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Guest&quot;</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;000000&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">roger.name <span class="comment">// &quot;Guest&quot;</span></span><br><span class="line">roger.id <span class="comment">// &quot;000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们把两个属性均设置了默认值，那么即使我们没有提供构造器，也是可以通过 <code>Person()</code> 构造出一个实例，这个实例的所有属性全是默认值。</p>
<h3 id="结构体的构造过程"><a href="#结构体的构造过程" class="headerlink" title="结构体的构造过程"></a>结构体的构造过程</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> longitude: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myLocation <span class="operator">=</span> <span class="type">Location</span>(latitude: <span class="number">39.1</span>, longitude: <span class="number">115.2</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，结构体中我们没有设置构造器，但还是使用了一个全参数的构造器完成了构造过程。</p>
<blockquote>
<p>如果没有自定义构造器，结构体会默认提供一个包含全部属性作为参数的构造器；如果结构体的所有属性均设置了默认值，那么还会额外提供一个无参数的构造器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span> <span class="operator">=</span> <span class="number">1.11</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span> <span class="operator">=</span> <span class="number">2.22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myLocation <span class="operator">=</span> <span class="type">Location</span>()</span><br><span class="line"><span class="keyword">var</span> myLocation2 <span class="operator">=</span> <span class="type">Location</span>(latitude: <span class="number">39.1</span>, longitude: <span class="number">115.2</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过无参数或者是全参数的构造器，都构造出了一个实例。</p>
<blockquote>
<p>需要说明的是，即使部分属性已经设置了默认值，那么系统默认提供的还是一个全参数的构造器。</p>
</blockquote>
<h3 id="枚举的构造过程"><a href="#枚举的构造过程" class="headerlink" title="枚举的构造过程"></a>枚举的构造过程</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Rating</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> perfect</span><br><span class="line">    <span class="keyword">case</span> great</span><br><span class="line">    <span class="keyword">case</span> good</span><br><span class="line">    <span class="keyword">case</span> bad</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">score</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> score &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">90</span><span class="operator">...</span><span class="number">100</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .perfect</span><br><span class="line">        <span class="keyword">case</span> <span class="number">80</span><span class="operator">..&lt;</span><span class="number">90</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .great</span><br><span class="line">        <span class="keyword">case</span> <span class="number">60</span><span class="operator">..&lt;</span><span class="number">80</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .good</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">60</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .bad</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rating1 <span class="operator">=</span> <span class="type">Rating</span>.perfect</span><br><span class="line"><span class="keyword">let</span> rating2 <span class="operator">=</span> <span class="type">Rating</span>(score: <span class="number">98</span>)</span><br></pre></td></tr></table></figure>

<p>通常情况下，枚举变量可以通过 <code>类型名.case名</code> 的形式构造，这也是绝大多数的使用方式，不过 Swift 中我们仍然可以为枚举添加构造器。上面的例子中，我们通过得分来构造一个表示等级的枚举变量。最终两种构造方式都可以构造出一个枚举变量&#x2F;常量。</p>
<p>需要说明的是，这个构造器是个可失败的构造器（它的语法就是在 <code>init</code> 后面增加一个问号），也就是允许构造失败（当传入的分数不在 0 到 100 的范围内的时候就构造失败），因此 <code>rating1</code> 的类型是 <code>Rating</code> 而 <code>rating2</code> 的类型是 <code>Rating?</code>，即它是一个可选型，使用时需要解包。</p>
<h2 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h2><h3 id="自定义构造器"><a href="#自定义构造器" class="headerlink" title="自定义构造器"></a>自定义构造器</h3><p>显然我们无法只使用系统提供的构造器，况且很多情况下系统并不为我们提供构造器，这就需要我们自定义构造器。</p>
<p>上述举例中其实已经涉及了自定义构造器，不过都是最基本的直接为属性赋值的方式，下面的例子可以看出，构造过程也可能存在更多的逻辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        name <span class="operator">=</span> firstName.capitalized <span class="operator">+</span> <span class="string">&quot; &quot;</span> <span class="operator">+</span> lastName.capitalized</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;roger&quot;</span>, lastName: <span class="string">&quot;federer&quot;</span>)</span><br><span class="line">roger.name <span class="comment">// &quot;Roger Federer&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中我们把传入的两个参数值通过一定的逻辑后赋值给 <code>name</code> 属性。</p>
<blockquote>
<p>一旦自定义了构造器，那么系统将不再提供任何默认的构造器，即使属性都存在默认值。类和结构体都是如此。</p>
</blockquote>
<p>需要说明的一点是，这个例子中，构造器中使用的是 <code>name</code> 而非前面的 <code>self.name</code>，这是完全没问题的，前面的例子是因为参数变量的名字和属性名同名，那么在函数作用域内部，局部变量就占用了这个名字了。</p>
<h3 id="构造器参数的默认值"><a href="#构造器参数的默认值" class="headerlink" title="构造器参数的默认值"></a>构造器参数的默认值</h3><p>在 Swift 中，构造器和普通函数一样，参数是可以提供默认值的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Guest&quot;</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> guest <span class="operator">=</span> <span class="type">Person</span>(age: <span class="number">50</span>)</span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Roger&quot;</span>, age: <span class="number">36</span>)</span><br><span class="line"></span><br><span class="line">guest.name <span class="comment">// &quot;Guest&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果参数设置了默认值，那么系统会额外奉送一个构造器，那就是省略了所有默认参数的版本，上面的例子中，我们仅仅通过 <code>age</code> 作为参数也构造出了一个实例。</p>
<h3 id="可失败的构造器"><a href="#可失败的构造器" class="headerlink" title="可失败的构造器"></a>可失败的构造器</h3><p>上面例子中，枚举的例子就是一个可失败的构造器，也就是允许返回 <code>nil</code>，响应的返回类型也是一个可选型。其语法很简单，就是 <code>init</code> 后面增加问号。</p>
<p>在 Swift 标准库中，可失败的构造器有很多</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">num1 <span class="comment">// 123 类型为 Int?</span></span><br><span class="line"><span class="keyword">let</span> num2 <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">num2 <span class="comment">// nil 类型为 Int?</span></span><br></pre></td></tr></table></figure>

<p>这是我们很常见的把字符串转为整型的方式，Swift 是通过 Int 的一个可失败的构造器完成的，因为很显然，不是所有的字符串都可以转成整型的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span>: <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d1 <span class="operator">=</span> <span class="type">Direction</span>(rawValue: <span class="number">0</span>) <span class="comment">// east</span></span><br><span class="line"><span class="keyword">let</span> d2 <span class="operator">=</span> <span class="type">Direction</span>(rawValue: <span class="number">4</span>) <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>有原始值的枚举通过原始值创建枚举变量的构造器也是一个可失败的构造器，上面的例子中，不是所有整数都能对应一个方向的。</p>
<blockquote>
<p>可失败的构造器的可失败性（暂且这么称呼吧）是可传递的，比如传递到便利构造器中（便利构造器后文会重点讲解）或者子类的构造器中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> name.count <span class="operator">&gt;</span> <span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个构造器如果不加 ? 就会报错 A non-failable initializer cannot chain to failable initializer &#x27;init(name:)&#x27; written with &#x27;init?&#x27;</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">studentNumber</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber <span class="operator">=</span> studentNumber</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;小泉纯一郎&quot;</span>, studentNumber: <span class="number">123456</span>) <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，我们假定 <code>name</code> 只能是中国人名，我们简单的限制字符数只能不大于 4，否则构造失败，那么 <code>Student</code> 类的构造器由于调用了父类的可失败的构造器，那么这个构造器就也要是一个可失败的构造器才行。</p>
<p>还有一种解决方式是处理最终构造出来的对象比如强制解包（<code>super.init(name: name)!</code>），但这显然是不推荐的。</p>
<h3 id="属性是可选型的情况下的构造过程"><a href="#属性是可选型的情况下的构造过程" class="headerlink" title="属性是可选型的情况下的构造过程"></a>属性是可选型的情况下的构造过程</h3><p>很多人一开始学习 Swift 时不理解为什么可选型属性可以不用初始化，只好死记硬背，其实这很好理解，只需要记住一句话：</p>
<blockquote>
<p>可选型属性即使只声明，其也有默认值，它的默认值是 nil</p>
</blockquote>
<p>也就是说，可选型属性即使只声明，其也具有默认值，这样就解释了为什么其“不用初始化”，实质上它和其他拥有默认值的属性一样，如果没有在构造器中初始化，那么构造过程就会默认用 nil 将其初始化。可选型本质上是枚举，nil 只是它的一个值而已。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> country: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Roger&quot;</span>)</span><br><span class="line">roger.country <span class="comment">// 构造器没有为其初始化，那么它就初始化成默认值 nil</span></span><br></pre></td></tr></table></figure>

<h2 id="类的两段式构造"><a href="#类的两段式构造" class="headerlink" title="类的两段式构造"></a>类的两段式构造</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>类因为有继承的特性，构造器不仅仅要完成本类属性初始化这么简单，它还要考虑父类继承来的属性如何初始化，以及其他逻辑的实现，于是就有了两段式构造的特征。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;000000&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">id</span>: <span class="type">String</span>, <span class="params">studentNumber</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一段构造，先进行本类的属性的初始化，再通过调用父类构造器完成继承自父类的属性的初始化</span></span><br><span class="line">        <span class="keyword">self</span>.studentNumber <span class="operator">=</span> studentNumber</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二段构造，为父类的其他提供默认值的属性初始化；完成其他逻辑，此时已经可以使用 self 调用实例方法或属性</span></span><br><span class="line">        <span class="keyword">self</span>.id <span class="operator">=</span> id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> harry <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Harry&quot;</span>, id: <span class="string">&quot;654321&quot;</span>, studentNumber: <span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个例子中，子类的构造器里我们做了三件事：</p>
<ul>
<li>为本类的属性初始化</li>
<li>通过调用父类构造器完成从父类继承的属性的初始化</li>
<li>为父类中已经提供默认值的属性初始化（当然这一步还可以做更多其他逻辑，可以调用实例方法）</li>
</ul>
<blockquote>
<p>“Notice that the initializer for the EquilateralTriangle class has three different steps:</p>
<ol>
<li>Setting the value of properties that the subclass declares.</li>
<li>Calling the superclass’s initializer.</li>
<li>Changing the value of properties defined by the superclass. Any additional setup work that uses methods, getters, or setters can also be done at this point.”</li>
</ol>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>
<p>其中前两步就是第一段的构造过程，这一段实质上已经完成了实例的构造，第一段构造构造完成，这个实例就已经可以使用了。</p>
<p>那么为什么还要第二段构造呢？我们可以看上面的例子，这个例子中，父类继承的属性 <code>id</code> 如何在子类中初始化呢？首先我们要知道父类继承来的属性必须通过调用父类构造器完成初始化，可是此时父类提供的构造器是把 <code>id</code> 属性按照其默认值进行初始化的，也就是说，在子类中，我们最初构造出的这个实例，其 <code>id</code> 属性只能是它的默认值 <code>000000</code>，那么我们在子类还希望按照自己的意愿为其赋初值啊？那么就应该在第二段构造过程中进行，这一段构造过程本质上其实并不再是赋初值的过程，而是更改值的过程（之前写短文讨论过属性观察器的触发时机，第二段构造中属性的赋值已经可以触发属性观察器了）。</p>
<p>额外说明一个小地方，这里 <code>super</code> 调用父类构造器是必须进行的吗？答案是是的！但还是有可以省略的情况的（省略不写不代表没有调用），但这既少见也不建议，比如下面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Guest&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">studentNumber</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber <span class="operator">=</span> studentNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> harry <span class="operator">=</span> <span class="type">Student</span>(studentNumber: <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">harry.name <span class="comment">// &quot;Guest&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Swift-中类的构造过程与-Objective-C-的对比"><a href="#Swift-中类的构造过程与-Objective-C-的对比" class="headerlink" title="Swift 中类的构造过程与 Objective-C 的对比"></a>Swift 中类的构造过程与 Objective-C 的对比</h3><p>很多程序员从 Objective-C 转到 Swift 后，都会有一个疑惑。</p>
<p>为什么 Objective-C 中 都是先调用 <code>super</code>，再为属性赋值，而 Swift 中却是颠倒，必须先为属性赋值，才能调用 <code>super</code> 呢？</p>
<p>阅读了前文相信不少人已经有了答案。我们先来看看 Objective-C 一般是怎么做的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QWPPerson 类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QWPPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QWPPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// QWPStudent 类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QWPStudent</span> : <span class="title">QWPPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> studentNumber;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andStudentNumber:(<span class="built_in">NSInteger</span>)studentNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QWPStudent</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andStudentNumber:(<span class="built_in">NSInteger</span>)studentNumber &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithName:name];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _studentNumber = studentNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>通常我们都是这样写的，很多文章里的解释是，我们先调用 <code>super</code> 完成父类的初始化，然后再进行本类的初始化。</p>
<p>我们对比一下 Swift，发现什么了么？其实很简单，这里所谓的“父类的初始化”，就是 Swift 中的第一段的构造过程，只不过 Objective-C 中所有属性都有默认值，那就是 0（nil 也是 0）。所以第一阶段构造实例的过程完全是把所有属性按照默认值去初始化构造出了这个实例，而所谓的“本类的初始化”就很像 Swift 中的第二段构造过程，这里实例已经创建（如果 if 判断成立的话），之后在里面其实是修改属性的值而已，从 0 修改成一个非 0 的值。</p>
<p>也就是说 Swift 的构造过程相对更灵活，它可以不必一开始只能用默认值去构造这个实例。所以 Swift 的构造过程并不是说把 <code>super</code> 交换到了后面，而是在 <code>super</code> 前面增加了更多的灵活性。</p>
<blockquote>
<p>“Swift’s two-phase initialization process is similar to initialization in Objective-C. The main difference is that during phase 1, Objective-C assigns zero or null values (such as 0 or nil) to every property. Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which 0 or nil is not a valid default value.”</p>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>
<p>对于 Objective-C，我们可以模仿 Swift 尝试一种从没写过的方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andStudentNumber:(<span class="built_in">NSInteger</span>)studentNumber &#123;</span><br><span class="line">    _studentNumber = studentNumber;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithName:name];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把 <code>studentNumber</code> 的属性初始化提前到 <code>super</code> 调用之前尝试一下，结果仍然可以成功创建实例。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>不管是默认提供的构造器，还是自定义的构造器，还是说类的两段式构造方式，其核心其实都在做一件事，那就是必须保证所有的属性都初始化！只有所有属性都初始化，这个实例才算构造完成，才可以使用。</p>
<h2 id="值类型的构造器代理（Initializer-Delegation）"><a href="#值类型的构造器代理（Initializer-Delegation）" class="headerlink" title="值类型的构造器代理（Initializer Delegation）"></a>值类型的构造器代理（Initializer Delegation）</h2><blockquote>
<p>“Initializers can call other initializers to perform part of an instance’s initialization. This process, known as initializer delegation, avoids duplicating code across multiple initializers.”</p>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>
<p>名字很唬人，但其实就是一个构造器中可以调用另一个构造器。</p>
<p>这一节我们只讨论值类型的，也就是不考虑类，我们以结构体为例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> size.width <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> size.height <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里我们调用了另一个构造器完成了构造过程</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当然这个例子我们也可以不通过调用其他构造器完成构造过程</span></span><br><span class="line">        <span class="comment">//        self.origin = Point(x: originX, y: originY)</span></span><br><span class="line">        <span class="comment">//        self.size = size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>self</code> 我们可以在一个构造器中调用另一个构造器，这简化了一些重复代码。</p>
<p>相信很多了解 Swift 的同学会发现，这和类中的便利构造器很像啊。是的，便利构造器也是一种构造器代理，只不过由于结构体没有继承的特性，那么这里的构造器不用区分什么便利不便利，大家都一样，不用加 <code>convenience</code> 关键字。</p>
<p>下面我们就逐步开始讲解 Swift 构造过程中较难的地方了，我们就从便利构造器开始。</p>
<h2 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h2><h3 id="便利构造器和指定构造器"><a href="#便利构造器和指定构造器" class="headerlink" title="便利构造器和指定构造器"></a>便利构造器和指定构造器</h3><blockquote>
<p>首先要确定，便利构造器和指定构造器的概念只存在于类中，值类型是不做区分的。<br>便利构造器也是构造器代理的一种情况。<br>类中的非便利构造器就是指定构造器。<br>便利构造器中仍然可以调用另一个便利构造器，这是没有问题的，但是最终都会去调用一个指定构造器。</p>
</blockquote>
<p>我们只提便利构造器的话，它也很简单，和上面值类型的情况差不多。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便利构造器必须增加 convenience 关键字</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: firstName <span class="operator">+</span> <span class="string">&quot; &quot;</span> <span class="operator">+</span> lastName, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Roger Federer&quot;</span>, age: <span class="number">36</span>)</span><br><span class="line"><span class="keyword">let</span> roger2 <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;Roger&quot;</span>, lastName: <span class="string">&quot;Federer&quot;</span>, age: <span class="number">36</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，和值类型不同的是，这里仅仅是多了一个 <code>convenience</code> 关键字，其他好像没什么区别，同样是增加了一个新的构造器。</p>
<p>那还为什么要加这个关键字呢？那是因为类是有继承的特性的，增加了这个维度，很多东西就复杂起来啦。</p>
<h3 id="构造器代理规则在类中的表现"><a href="#构造器代理规则在类中的表现" class="headerlink" title="构造器代理规则在类中的表现"></a>构造器代理规则在类中的表现</h3><p>前面我们了解了构造器的代理，其实就是一个构造器可以调用另一个构造器嘛，但是在加入继承这一维度之前，它们都是在调用本类中的其他构造器而已。</p>
<p>再往前面的例子中，我们有继承的例子，那些例子中我们在子类的构造器中通过 <code>super</code> 关键字调用了父类的构造器，事实上这也是构造器代理。</p>
<p>那么在类中，构造器代理满足什么样的规则呢？</p>
<blockquote>
<p>Rule 1<br>A designated initializer must call a designated initializer from its immediate superclass.<br>Rule 2<br>A convenience initializer must call another initializer from the same class.<br>Rule 3<br>A convenience initializer must ultimately call a designated initializer.”</p>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>
<p>总结下来就是三点：</p>
<ul>
<li>指定构造器只能调用父类的指定构造器（注意无法调用父类的便利构造器哦）</li>
<li>便利构造器只能调用本类中的其他构造器（便利构造器中无法使用 <code>super</code> 关键字而只能使用 <code>self</code>）</li>
<li>便利构造器最终一定会调用到一个指定的构造器（也就是说实例的构建本质上还是在指定构造器中构建的，便利构造器没有构造实例的能力，需要最终依靠指定构造器）</li>
</ul>
<p>下面这张图形象地解释了这种关系：</p>
<p><img src="https://raw.githubusercontent.com/qiweipeng/images/master/20201001105919.png"></p>
<p>图 1 - 构造器代理</p>
<p>这样又我们可以把上面的三点总结为两点：</p>
<ul>
<li>指定构造器只能纵向调用</li>
<li>便利构造器只能横向调用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便利构造器只能调用本类中的其他构造器</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: firstName <span class="operator">+</span> <span class="string">&quot; &quot;</span> <span class="operator">+</span> lastName, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">studentNumber</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber <span class="operator">=</span> studentNumber</span><br><span class="line">        <span class="comment">// 指定构造器只能调用父类的指定构造器</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 便利构造器只能调用本类中的其他构造器</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">id</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里我们假定学生的号码就是 id 号码前面加 2018</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, age: age, studentNumber: <span class="string">&quot;2018&quot;</span> <span class="operator">+</span> id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，就完全遵守这样的规则。</p>
<h3 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h3><h4 id="构造器的继承"><a href="#构造器的继承" class="headerlink" title="构造器的继承"></a>构造器的继承</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: firstName <span class="operator">+</span> <span class="string">&quot; &quot;</span> <span class="operator">+</span> lastName, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的父类我们仍然定义一个 <code>Person</code> 类，拥有一个指定构造器和一个便利构造器；接下来我们设置一个子类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;000000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了测试构造器的继承，我们在这个子类中什么构造器都没写，只增加了一个具有默认值的属性；结果会怎么样呢？结果就是，我们可以成功使用前面的两个构造器构造出 <code>Student</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> harry <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Harry&quot;</span>, age: <span class="number">11</span>)</span><br><span class="line"><span class="keyword">let</span> hermione <span class="operator">=</span> <span class="type">Student</span>(firstName: <span class="string">&quot;Hermione&quot;</span>, lastName: <span class="string">&quot;Granger&quot;</span>, age: <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>是的，我们成功从父类继承了他的所有构造器，一个指定构造器，一个便利构造器。</p>
<p>我们总结一下上面代码有什么特征：</p>
<ul>
<li>子类的所有属性都提供了默认值</li>
<li>子类没有定义任何指定构造器（当然也不会定义便利构造器）</li>
</ul>
<p>带来的结果呢：</p>
<ul>
<li>子类继承了父类所有构造器，包括指定构造器和便利构造器</li>
</ul>
<p>现在我们开始改变了，首先我们尝试去掉子类属性 <code>studentNumber</code> 的默认值；结果报错了！提示 <code>Class &#39;Student&#39; has no initializers</code>，它告诉我们 <code>Student</code> 类没有构造器！刚才我们还继承了两个构造器，现在一下子一个也没有了。</p>
<p>我们发现子类因为含有没有赋默认值的属性，父类的所有构造器就不再供子类继承了。这是为什么呢？答案很简单，因为父类的构造器无法完成子类属性的初始化。父类并不知道子类有什么属性，我们假设此时可以使用父类的构造器完成构造过程，那么子类的这个 <code>studentNumber</code> 属性应该被初始化成什么呢？</p>
<p>于是我们只好自己自定义构造器了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">studentNumber</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber <span class="operator">=</span> studentNumber</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建一个构造器，然后尝试创建实例，通过代码提示可以看到，此时子类只有一个构造器，就是我们新创建的这个构造器。父类的构造器仍然没有被继承。</p>
<p>于是突然想到了父类方法是可以重写的，那么父类的构造器是否也能重写呢？答案是是的，我们此时可以重写父类的指定构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面加 override 关键字实现对父类构造器的重写</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    studentNumber <span class="operator">=</span> <span class="string">&quot;000000&quot;</span></span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们自己定义了一个，然后重写一个父类的，那么我们现在应该有两个了吧！我们尝试一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> harry <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Harry&quot;</span>, age: <span class="number">11</span>, studentNumber: <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> hermione <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Hermione&quot;</span>, age: <span class="number">12</span>)</span><br><span class="line"><span class="keyword">let</span> ron <span class="operator">=</span> <span class="type">Student</span>(firstName: <span class="string">&quot;Ron&quot;</span>, lastName: <span class="string">&quot;Weasley&quot;</span>, age: <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>我们竟然拥有了三个构造器！原来父类的便利构造器现在又被继承了！原因是：</p>
<ul>
<li>如果子类提供了所有父类指定构造器的实现，那么子类将继承父类所有的便利构造器</li>
</ul>
<p>这样，我们基本就了解了构造器的继承原则，它最终可以总结成下面两句话：</p>
<ul>
<li>当我们没有实现任何自定义构造器的情况下，子类继承所有父类指定构造器和便利构造器（当然这种情况一定是子类所有属性都有默认值的情况，不然会报错）</li>
<li>当我们重写了所有父类指定构造器的情况下，子类额外继承父类的所有便利构造器</li>
</ul>
<p>当然也可以参考官方的说法，大同小异：</p>
<blockquote>
<p>Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:<br>Rule 1<br>If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.<br>Rule 2<br>If your subclass provides an implementation of all of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.”</p>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>
<h4 id="构造器的重写"><a href="#构造器的重写" class="headerlink" title="构造器的重写"></a>构造器的重写</h4><p>我们刚才注意到了，构造器是可以重写的，但是我们只重写了指定构造器。那么就有疑问了，便利构造器是否可以重写呢？答案是否定的，便利构造器无法被重写。但是有的同学却是看到过 <code>override convenience init</code> 的字眼出现，这是怎么回事呢？</p>
<p>这是因为重写的父类指定构造器可以是便利构造器，但是便利构造器无法被重写！这里有些绕，我们拿官方的例子说明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">&quot;[Unnamed]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/qiweipeng/images/master/20201001105926.png"></p>
<p>图 2 - 构造器重写1</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecipeIngredient</span>: <span class="title class_ inherited__">Food</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们此时又定义一个 <code>RecipeIngredient</code> 类，这个类中有一个自定义的构造器，它通过调用父类指定构造器完成构造；同时还有一个便利构造器，这个构造器通过调用本类的指定构造器完成构造；巧合的是，这个便利构造器和父类的那个指定构造器长的一模一样！于是没办法，它既是一个便利构造器，又完成了父类指定构造器的重写，所以又加上了 <code>override</code> 关键字。</p>
<p>目前这两个类的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/qiweipeng/images/master/20201001105933.png"></p>
<p>图 3 - 构造器重写2</p>
<blockquote>
<p>子类并不是重写了一个父类的便利构造器，而是通过便利构造器的方式完成了对父类指定构造器的重写。</p>
</blockquote>
<p>于是我们又满足了上面的第二条原则，我们重写了所有父类的指定构造器，于是父类的所有便利构造器也被子类继承，现在子类拥有三个构造器。</p>
<h3 id="required-构造器"><a href="#required-构造器" class="headerlink" title="required 构造器"></a>required 构造器</h3><blockquote>
<p>构造器加上 required 关键字代表子类必须实现</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父类指定构造器</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父类便利构造器</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: firstName <span class="operator">+</span> <span class="string">&quot; &quot;</span> <span class="operator">+</span> lastName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于 required 的构造器, 重载不需要再写 override, 而是还写 required</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        studentNumber <span class="operator">=</span> <span class="number">000</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 required 的构造器, 重载不需要再写 override, 而是还写 required。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2018/03/08/property-observers-in-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/08/property-observers-in-swift/" class="post-title-link" itemprop="url">Swift 中的 willSet 和 didSet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 23:56:49" itemprop="dateCreated datePublished" datetime="2018-03-08T23:56:49+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>willSet 和 didSet 在 Swift 中用于监控存储型属性的变化，被称为属性观察器（Property Observers）。其用法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Guest&quot;</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Name: willSet&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Name: didSet&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roger <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Roger&quot;</span>)</span><br><span class="line">roger.name <span class="operator">=</span> <span class="string">&quot;Rafa&quot;</span> <span class="comment">// 此时触发属性观察器</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<ul>
<li>属性观察器只可用于存储型属性，不能用在计算型属性；</li>
<li>属性观察器不会监控属性初始化过程，即属性首次赋值的时候是不会被监控的，如上面代码的构造函数是不会被监控的，即使属性声明的时候已经初始化；</li>
<li>但是不代表构造函数执行一定不会触发属性观察器，下面会举例。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Guest&quot;</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Name: willSet&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Name: didSet&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">studentNumber</span>: <span class="type">Int</span>, <span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber <span class="operator">=</span> studentNumber</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> andy <span class="operator">=</span> <span class="type">Student</span>(studentNumber: <span class="number">123456</span>, name: <span class="string">&quot;Andy&quot;</span>) <span class="comment">// 构造函数触发属性观察器</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，Student 类的构造函数完成了三件事：</p>
<ol>
<li>初始化自身属性；</li>
<li>调用父类构造函数，初始化父类属性并完成构造过程，此时构造过程已经完成；</li>
<li>为父类的属性按照子类的要求设置默认值，此时虽然是在构造函数中完成，但实质上已经在做构造过程之后的事情了，这时属性的修改就会触发属性观察器。</li>
</ol>
<blockquote>
<ol>
<li>Setting the value of properties that the subclass declares.</li>
<li>Calling the superclass’s initializer.</li>
<li>Changing the value of properties defined by the superclass. Any additional setup work that uses methods, getters, or setters can also be done at this point.”</li>
</ol>
</blockquote>
<blockquote>
<p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 4.1).” iBooks. </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2017/11/20/binary-thinking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/20/binary-thinking/" class="post-title-link" itemprop="url">关于进制的一点小思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-20 20:58:12" itemprop="dateCreated datePublished" datetime="2017-11-20T20:58:12+08:00">2017-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>int 类型占用 4 个字节，最小的那个数是 -2147483648，它的补码是 <code>10000000 00000000 00000000 00000000</code>，反码是 <code>11111111 11111111 11111111 11111111</code>，原码是 <code>10000000 00000000 00000000 00000000</code>，也就是原码和补码是一样的。</p>
<p>如果忽略符号位，那么 -2147483648 和 0 的二进制位是一样的。事实上 int 类型的二进制码从 32 个 0 到 32 个 1，分别对应的数是 0，1，2，……，2147483646，2147483647（对应 0 后面 31 个 1），-2147483648（对应 1 后面 31 个 0），-2147483647，……，-3，-2，-1（对应 32 个 1）；也就是说如果符号位不同其他位都相同叫做“对应”的话：0 和 -2147483648 对应，1 和 -2147483647 对应，……，2147483647 和 -1 对应。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>尝试打印 int 类型的正整数中的前 256 个数和后 256 个数，可能会想到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 打印 int 类型的正整数中的前 256 个数和后 256 个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0b00000000000000000000000000000000</span>; i &lt;= <span class="number">0b00000000000000000000000011111111</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0b01111111111111111111111100000000</span>; j &lt;= <span class="number">0b01111111111111111111111111111111</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上第一个循环是没有问题的，但是第二个循环，当打印完最大一个数即 2147483637 后，循环没有停止，而是继续从负的最小一个数开始继续往上打印；原因是 <code>0b01111111111111111111111111111111</code> 之后的这个 j++ 自增运算得到的结果是小于 j 的，即直接跳到 -2147483638 去了；也就是 “2147483637 + 1 &#x3D; -2147483638”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2017/08/20/array-dictionary-set-in-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/20/array-dictionary-set-in-swift/" class="post-title-link" itemprop="url">记一下 Swift 中数组、字典、集合的基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-20 23:06:22" itemprop="dateCreated datePublished" datetime="2017-08-20T23:06:22+08:00">2017-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Swift 语法还在变动中，好不容易记住的等版本一升级又变了。这次正好记一下最新的数组、字典、集合的基本操作，用的时候可以查询。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line">numbers.count <span class="comment">// 元素数量</span></span><br><span class="line">numbers.isEmpty <span class="comment">// 数组是否为空</span></span><br><span class="line">numbers[<span class="number">2</span>] <span class="comment">// 数组下标元素</span></span><br><span class="line">numbers.first <span class="comment">// 首个元素（可选型）</span></span><br><span class="line">numbers.last <span class="comment">// 最后一个元素（可选型）</span></span><br><span class="line">numbers.max() <span class="comment">// 数组最大元素（可选型）</span></span><br><span class="line">numbers.contains(<span class="number">3</span>) <span class="comment">// 是否包含某个元素</span></span><br><span class="line">numbers.contains &#123; (num) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    num <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line">&#125; <span class="comment">// 是否包含大于 10 的数</span></span><br><span class="line">numbers.contains &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">10</span>&#125; <span class="comment">// 上条代码的简写</span></span><br><span class="line">numbers.index(of: <span class="number">7</span>) <span class="comment">// 某个元素首次出现的下标（可选型）</span></span><br><span class="line"></span><br><span class="line">numbers.append(<span class="number">2</span>) <span class="comment">// 末尾添加一个元素</span></span><br><span class="line">numbers.append(contentsOf: [<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]) <span class="comment">// 末尾增添一个数组</span></span><br><span class="line">numbers <span class="operator">+=</span> [<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>] <span class="comment">// 上句代码的简写</span></span><br><span class="line">numbers.insert(<span class="number">10</span>, at: <span class="number">3</span>) <span class="comment">// 在某个位置插入元素</span></span><br><span class="line"></span><br><span class="line">numbers.removeFirst() <span class="comment">// 删除第一个元素</span></span><br><span class="line">numbers.removeLast() <span class="comment">// 删除最后一个元素</span></span><br><span class="line">numbers.remove(at: <span class="number">4</span>) <span class="comment">// 删除指定位置元素</span></span><br><span class="line">numbers.removeAll() <span class="comment">// 删除所有元素</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">4</span>] <span class="operator">=</span> <span class="number">11</span> <span class="comment">// 修改指定位置元素</span></span><br><span class="line">numbers[<span class="number">1</span><span class="operator">...</span><span class="number">3</span>] <span class="operator">=</span> [<span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">55</span>, <span class="number">7</span>] <span class="comment">// 将指定范围元素替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组遍历</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;swift&quot;</span>: <span class="string">&quot;燕子&quot;</span>, <span class="string">&quot;python&quot;</span>: <span class="string">&quot;蟒蛇&quot;</span>]</span><br><span class="line"></span><br><span class="line">dict.count <span class="comment">// 字典元素数量</span></span><br><span class="line">dict.isEmpty <span class="comment">// 字典是否为空</span></span><br><span class="line">dict[<span class="string">&quot;swift&quot;</span>] <span class="operator">=</span> <span class="string">&quot;雨燕&quot;</span> <span class="comment">// 增、改 返回新值</span></span><br><span class="line">dict.updateValue(<span class="string">&quot;大蟒&quot;</span>, forKey: <span class="string">&quot;python&quot;</span>) <span class="comment">// 改 返回旧值</span></span><br><span class="line">dict[<span class="string">&quot;swift&quot;</span>] <span class="comment">// 查 （可选型）</span></span><br><span class="line">dict.removeValue(forKey: <span class="string">&quot;java&quot;</span>) <span class="comment">//删</span></span><br><span class="line">dict[<span class="string">&quot;java&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">// 删</span></span><br><span class="line"></span><br><span class="line"><span class="type">Array</span>(dict.keys) <span class="comment">// 将字典所有键放进一个数组中</span></span><br><span class="line"><span class="type">Array</span>(dict.values) <span class="comment">// 将字典的所有值放进一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字典的键值对</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    key</span><br><span class="line">    value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合必须显式声明类型,并且没有快速创建的方法</span></span><br><span class="line"><span class="keyword">var</span> setA: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> setB: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> setC: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明空集合</span></span><br><span class="line"><span class="keyword">var</span> emptySet1: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">var</span> emptySet2 <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Double</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> emptySet3: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组转成集合</span></span><br><span class="line"><span class="keyword">var</span> vowels <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span>])</span><br><span class="line"></span><br><span class="line">vowels.first <span class="comment">// 集合中随意一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的添加</span></span><br><span class="line">setC.insert(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">setC.insert(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">setC.insert(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">setC.insert(<span class="string">&quot;E&quot;</span>) <span class="comment">// 重复添加是没效果的</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">setC.remove(<span class="string">&quot;E&quot;</span>)</span><br><span class="line"><span class="comment">//skillsOfC.removeAll() // 删除所有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的交并等运算,事实上数组也能用这些方法</span></span><br><span class="line">setA.union(setB) <span class="comment">// 交 但 skillsOfA 本身没有发生改变</span></span><br><span class="line">skillsOfA.formUnion(skillsOfB) <span class="comment">// 交 skillsOfA 改变</span></span><br><span class="line">setA.intersection(setB) <span class="comment">// 并, 本身不改变</span></span><br><span class="line">skillsOfA.formIntersection(skillsOfB) <span class="comment">// 并,本身改变</span></span><br><span class="line">setA.subtracting(setC) <span class="comment">// A有C没有,本身不改变</span></span><br><span class="line">skillsOfA.subtract(skillsOfC) <span class="comment">// A有C没有,本身改变</span></span><br><span class="line">setA.symmetricDifference(setC) <span class="comment">// 亦或,即A和C 中除去共有剩下的部分, 本身不改变</span></span><br><span class="line">setA.formSymmetricDifference(setC) <span class="comment">// 亦或,本身改变</span></span><br><span class="line">setC.isSubset(of: setA) <span class="comment">// 判断子集</span></span><br><span class="line">setC.isStrictSubset(of: setA) <span class="comment">// 判断真子集</span></span><br><span class="line">setA.isSuperset(of: setC) <span class="comment">// 判断超集</span></span><br><span class="line">setA.isStrictSuperset(of: setC) <span class="comment">// 判断真超集</span></span><br><span class="line">setA.isDisjoint(with: setC) <span class="comment">// 判断相离,就是看是否有共同元素</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2017/08/02/carthage-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/02/carthage-usage/" class="post-title-link" itemprop="url">Carthage 的安装和使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-02 16:52:41" itemprop="dateCreated datePublished" datetime="2017-08-02T16:52:41+08:00">2017-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近尝试了 Carthage，这个工具有点在于侵入型小，它只是把 Github 的库拉下来打包成静态库，然后自己去关联这个 framework 就好啦。不像 CocoPods 还创建了 workspace。</p>
<h2 id="安装-Carthage"><a href="#安装-Carthage" class="headerlink" title="安装 Carthage"></a>安装 Carthage</h2><ul>
<li>Terminal 执行 <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code> 安装 Homebrew；</li>
<li><code>brew update</code> 更新 Homebrew 到最新版本；</li>
<li><code>brew install carthage</code> 安装 Carthage；</li>
</ul>
<h2 id="使用-Carthage"><a href="#使用-Carthage" class="headerlink" title="使用 Carthage"></a>使用 Carthage</h2><p><code>carthage version</code> 查看 Carthage 版本</p>
<p>使用 Carthage 安装第三方库流程</p>
<ul>
<li>Terminal 更改至项目所在文件夹；</li>
<li><code>touch Cartfile</code> 创建一个空的 Carthage 文件；</li>
<li><code>vim Cartfile</code> 或者 <code>open -a Xcode Cartfile</code> 打开文件，输入如 <code>github &quot;Alamofire/Alamofire&quot; ~&gt; 3.0</code>（其中版本号可选），保存关闭文件；</li>
<li><code>carthage update --platform iOS</code>，Carthage 开始下载和编译第三方库，完成后项目所在文件夹中多了 <code>Cartfile.resolved</code> 文件 和 <code>Carthage</code> 文件夹；<ul>
<li><code>Cartfile.resolved</code> 文件确保提交的项目可以使用完全相同的配置与方式运行启用。 跟踪项目当前所用的依赖版本号，保持多端开发一致,出于这个原因,强烈建议提交这个文件到版本控制中；</li>
<li><code>Carthage</code> 文件夹中有两个文件夹，分别是 <code>Build</code> 和 ；<code>Checkouts</code><ul>
<li><code>Build</code> 文件夹是编译后的 framework 文件；</li>
<li><code>Checkouts</code> 是拉取的依赖库源文件；</li>
</ul>
</li>
</ul>
</li>
<li>打开项目，点击 project，选择 target， 再选择上方的 General，将需要的 framework 文件拖到 Embedded Binaries 中，此时 Linked frameworks and Binaries 内也会出现；</li>
</ul>
<h2 id="其他工具常用命令"><a href="#其他工具常用命令" class="headerlink" title="其他工具常用命令"></a>其他工具常用命令</h2><p>既然写了这篇文章，就把之前总结的其他工具的常用命令也放上来吧。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>常用到如 Carthage、Git、Ruby、SQLite、Vim 等都可以通过 Homebrew 安装。</p>
<ul>
<li><p>安装 <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
</li>
<li><p>查看安装列表 <code>brew list</code></p>
</li>
<li><p>更新自身 <code>brew update</code></p>
</li>
<li><p>更新全部安装的包 <code>brew upgrade</code></p>
</li>
<li><p>查看帮助 <code>brew -help</code></p>
</li>
</ul>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li>查看版本 <code>git --version</code></li>
</ul>
<h3 id="RubyGems"><a href="#RubyGems" class="headerlink" title="RubyGems"></a>RubyGems</h3><ul>
<li><p>查看版本 <code>gem -v</code></p>
</li>
<li><p>官网查看最新版本 <a target="_blank" rel="noopener" href="https://rubygems.org/pages/download">https://rubygems.org/pages/download</a></p>
</li>
<li><p>更新到最新 <code>gem update --system</code></p>
</li>
<li><p>查看本地安装列表 <code>gem list</code></p>
</li>
<li><p>更新所有 Gems 到最新版本 <code>gem update</code></p>
</li>
<li><p>显示帮助 <code>gem --help</code></p>
</li>
<li><p>查看所有命令 <code>gem help commands</code></p>
</li>
</ul>
<h3 id="CocoPods"><a href="#CocoPods" class="headerlink" title="CocoPods"></a>CocoPods</h3><p>依赖 RubyGems：</p>
<ul>
<li>查看所有命令 ‘pod –help’</li>
<li>为指定路径安装 CocoPods <code>cd 指定路径</code> <code>pod init</code></li>
<li>设置好 Podfile 之后安装 <code>pod init</code></li>
<li>为项目卸载 CocoPods <code>cd 指定路径</code> <code>pod deintegrate</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2017/07/23/function-in-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/23/function-in-swift/" class="post-title-link" itemprop="url">Swift 函数式编程入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-23 21:17:04" itemprop="dateCreated datePublished" datetime="2017-07-23T21:17:04+08:00">2017-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>是的，这真的只是入门，一点点了解而已，真正的函数式编程还差得远呢。只是初步学习了一些入门的思想，争取为以后的开发中提供一些便利。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先记一个 Swift 函数中的变化，其实也不能说是变化，因为在 Swift 3 就已经是这样了，就是函数中的参数已经不能使用 var 了，也就是函数参数全都是常量，如果希望在函数内部改变，那么只有在函数内部重新声明一个变量去接收这个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test</span>(<span class="params">number</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> newNumber <span class="operator">=</span> number</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对 newNumber 进行操作</span></span><br><span class="line">    <span class="keyword">return</span> newNumber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们如果想直接操作实参呢？更加复杂，需要增加 inout 关键字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addOne</span>(<span class="params">number</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    number <span class="operator">=</span> number <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">addOne(number: <span class="operator">&amp;</span>num)</span><br><span class="line">num <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>函数式编程更希望函数像是一个黑匣子一样，参数传进去，黑匣子经过一定逻辑然后返回一个结果，而并不希望我们直接操作这个参数，因此 Swift 函数参数默认都是值传递。</p>
<p>那么我们希望交换两个数呢？这时候肯定还是需要使用 inout 的嘛，我们定义这样一个函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>( <span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>,<span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> y <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>x, <span class="operator">&amp;</span>y) <span class="comment">// 调用函数的时候,含有 inout 关键字的变量前面会有一个 &amp;,表示地址</span></span><br></pre></td></tr></table></figure>

<p>当然事实上，Swift 给我们提供了 swap 函数，并且是支持泛型的，也就可以交换两个字符串，两个对象，两个很多东西。我们来自己实现一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwo</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> y <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">swapTwo(<span class="operator">&amp;</span>x, <span class="operator">&amp;</span>y)</span><br></pre></td></tr></table></figure>

<p>到这里还都是函数的基本使用，没有多少函数式编程的东西啊。</p>
<h2 id="函数式编程入门"><a href="#函数式编程入门" class="headerlink" title="函数式编程入门"></a>函数式编程入门</h2><p>Swift 为什么说它支持函数式编程呢，其中一点就是它把函数列为了“一等公民”，函数可以作为变量，可以作为参数，可以作为返回值，这为函数式编程打下了基础。</p>
<h3 id="函数作为变量-常量"><a href="#函数作为变量-常量" class="headerlink" title="函数作为变量&#x2F;常量"></a>函数作为变量&#x2F;常量</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">num1</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">num2</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add2 <span class="operator">=</span> add <span class="comment">// 这里直接将函数名赋值给一个常量</span></span><br><span class="line"></span><br><span class="line">add(num1: <span class="number">3</span>, num2: <span class="number">5</span>) <span class="comment">// 8</span></span><br><span class="line">add2(<span class="number">3</span>, <span class="number">5</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>我们把一个函数名直接赋值给了一个常量，此时 add2 的类型为 <code>(Int, Int) -&gt; Int</code>，也就是说这个变量是一个函数类型的，之后我们使用 <code>add2(3, 5)</code> 的方式依然可以调用这个函数（只不过没有了参数名）。</p>
<h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>我们都熟悉 Objective-C 中的 Block，而 Swift 中的 Closure 其实和 Block 是一回事儿，都是匿名函数。Swift 由于函数可以作为变量，我们原来传入闭包的地方现在传入一个函数变量是完全没问题的。</p>
<h4 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort 函数"></a>sort 函数</h4><p>比如 Swift 中的 sort 函数（sorted() 有返回值，不改变自身，sort() 返回类型为 Void，改变自身；事实上 Swift 中很多类似方法都是这样的，加后缀的一般都是有返回值不改变自身的）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers <span class="operator">=</span> [<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">bigFirst</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">&gt;</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numbers.sort(by: bigFirst) <span class="comment">// [12, 7, 7, 4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// numbers.sort(by: &gt;) // &gt; 本质上就是一个函数，因此这样也是可以的</span></span><br></pre></td></tr></table></figure>

<p>上面就是函数作为参数的一个例子，这里的 sort 函数称为高阶函数。</p>
<p>我们能传入函数的地方也能传一个闭包。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers.sort &#123; (num1, num2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> num1 <span class="operator">&gt;</span> num2</span><br><span class="line">&#125;</span><br><span class="line">numbers.sort &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; <span class="comment">// 参数可以使用默认的$0,$1...，由于只有一行代码，return 也可以省略</span></span><br></pre></td></tr></table></figure>

<p>当然，sort 函数能实现的功能可不知这些，比如下面，我们可以把一个整型数组按照字符串的顺序排序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers <span class="operator">=</span> [<span class="number">123</span>, <span class="number">110</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">235</span>, <span class="number">20</span>, <span class="number">315</span>]</span><br><span class="line"></span><br><span class="line">numbers.sort &#123; <span class="type">String</span>(<span class="variable">$0</span>) <span class="operator">&lt;</span> <span class="type">String</span>(<span class="variable">$1</span>) &#125; <span class="comment">// [1, 110, 123, 20, 23, 235, 315]</span></span><br></pre></td></tr></table></figure>

<p>下面介绍所有支持函数式编程的语言都基本会有的三个函数，那就是著名的 map, filter 和 reduce 函数。</p>
<h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h4><p>map 函数作用在数组上，我们传入一个函数，告诉这个数组每一个元素应该按照什么样的逻辑发生改变，那么 map 操作就会把数组中的所有元素均按照这个逻辑去改变，并返回一个新的数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers.map &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125; <span class="comment">// 数组所有元素均加 1</span></span><br><span class="line">numbers.map &#123; <span class="type">String</span>(<span class="variable">$0</span>) &#125; <span class="comment">// 将所有元素均转成字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h4><p>filter 函数，我们传入一个返回值为 Bool 的函数，所有返回值为 true 的元素会被放进一个新的数组中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.filter &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">5</span>&#125; <span class="comment">// 将所有大于 5 的数挑选出来组成一个新的数组</span></span><br></pre></td></tr></table></figure>

<h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h4><p>reduce 函数是把数组中所有的元组组成一个值，比如数组中所有元素的和，所有元素的积，都可以使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers <span class="operator">=</span> [<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">numbers.reduce(<span class="number">0</span>, <span class="operator">+</span>) <span class="comment">// 所有元素的和</span></span><br><span class="line">numbers.reduce(<span class="string">&quot;&quot;</span>) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="type">String</span>(<span class="variable">$1</span>) <span class="operator">+</span> <span class="string">&quot; &quot;</span> &#125; <span class="comment">// 返回 &quot;4 7 2 1 7 12 3 &quot;这样一个字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>王巍的《Swifter - Swift 必备 Tips》第一篇就是讲的柯里化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addOne</span>(<span class="keyword">_</span> <span class="params">num</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>上面的函数把一个整型加 1，可是如果我们还需要一个加 2 的函数呢，再写一个？如果需要加 3 的函数呢？再从头到尾写一个？</p>
<p>事实上我们可以定义一个高阶函数，把这几个函数的相同部分抽取出来，如下面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTo</span>(<span class="keyword">_</span> <span class="params">adder</span>: <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; num <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> adder <span class="operator">+</span> num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addFour <span class="operator">=</span> addTo(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">addFour(<span class="number">5</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>柯里化其实就是把一个多参数的函数，通过抽取高阶函数，把参数的传入分层的过程。我们利用它可以做什么？如果我们有多个函数，它们拥有部分相同的逻辑，我们就可以考虑把这部分逻辑抽取出来，达到代码复用的目的。</p>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>这里使用慕课网中刘宇波老师的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照重量的1倍计算邮费</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">tier1MailFeeByWeight</span>(<span class="params">weight</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="operator">*</span> weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照重量的3倍计算邮费</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">tier2MainFeeByWeight</span>(<span class="params">weight</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> <span class="operator">*</span> weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据重量的不同,选择不同的邮费计算方式,当重量小于等于10的时候选择1倍计算邮费,否则选择3倍计算邮费</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">chooseMailFeeCalculationByWeight</span>(<span class="params">weight</span>: <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> weight <span class="operator">&lt;=</span> <span class="number">10</span> <span class="operator">?</span> tier1MailFeeByWeight : tier2MainFeeByWeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">feeByUnitPrice</span>(<span class="params">price</span>: <span class="type">Int</span>, <span class="params">weight</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里根据参数的不同,可以得到不同的函数作为返回值</span></span><br><span class="line">    <span class="keyword">let</span> mailFeeByWeight <span class="operator">=</span> chooseMailFeeCalculationByWeight(weight: weight)</span><br><span class="line">    <span class="keyword">return</span> mailFeeByWeight(weight) <span class="operator">+</span> price <span class="operator">*</span> weight</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2017/06/25/optional-in-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/25/optional-in-swift/" class="post-title-link" itemprop="url">详解可选型（Optional）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-25 22:51:50" itemprop="dateCreated datePublished" datetime="2017-06-25T22:51:50+08:00">2017-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通常在其他语言中，nil 的本质就是 0，用 0 代表没有；但是 Swift 认为，0 应该是和其他整数一样的呀？程序员怎么知道 0 就是没有而不是 0 本身呢？于是，在 Swift 中出现了可选型的概念。在 Swift 中，nil 代表空，代表没有，nil 就是 nil，不再是一个整数 0 了。</p>
<h2 id="可选型的基本使用"><a href="#可选型的基本使用" class="headerlink" title="可选型的基本使用"></a>可选型的基本使用</h2><p>可选型写法很简单，普通类型后面加 <code>?</code> 就可以了；通常一个变量如果不应该为空，一定要存在，那么就不应该设置为可选型，比如身份证号，每个人都一定有，那么就不要设置成可选型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id: <span class="type">Int</span></span><br></pre></td></tr></table></figure>

<p>如果这个变量可以为空，比如错误信息，错误信息可能有也可能没有，那么就适合设置成可选型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage: <span class="type">String</span>?</span><br></pre></td></tr></table></figure>

<p>可选型的使用必须经过一个步骤就是解包（Unwrapp），<strong>可选型是无法直接使用的</strong>。</p>
<p>最简单的解包方式就是强制解包，含义为程序员保证这个可选型变量&#x2F;常量一定不会空；而如果其真的为空了就会崩溃，因此这是有风险的，程序员必须能保证才行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// serverResponseCode = nil // 如果加上这句代码，强制解包失败就会崩溃</span></span><br><span class="line"><span class="comment">// 另外，只有可选型可以设置成 nil，非可选型是无法设置为 nil 的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code <span class="operator">=</span> serverResponseC！ <span class="comment">// 此时 code 为 Int 类型</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，比如网络请求得到的数据，我们无法保证其一定不会 nil，此时就应该通过判断来非暴力的解包，我们通常能想到的应该是下面这样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> serverResponseCode <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> code <span class="operator">=</span> serverResponseCode<span class="operator">!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，因为可选型解包是一个常用操作，Swift 为我们专门提供了简化语法，下面的语法和上面的完全等价</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> severResponseCode <span class="operator">=</span> serverResponseCode &#123;</span><br><span class="line">    <span class="comment">// 此时，大括号内的 severResponseCode 就变成了一个 Int 类型，可以直接使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个可选型同时需要解包，那么它们可以并列写在同一个 if 语句里</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line"><span class="keyword">var</span> serverResponseMessage: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> severResponseCode <span class="operator">=</span> serverResponseCode, <span class="keyword">let</span> serverResponseMessage <span class="operator">=</span> serverResponseMessage &#123;</span><br><span class="line">    <span class="comment">// 这个作用域内，解包后的变量可以直接使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，可以使用 if 的一般都可以使用 guard，本文就不涉及 guard 的使用了。</p>
<p>可见可选型的基本使用并不难，可为空就设置成可选型，用的时候就需要解包，这样就可以了。那么，Swfit 为什么要给程序员添加这个麻烦呢？当然是为了安全啦，可以这么说，只要程序员合理使用可选型，原来在 Objective-C 中的野指针访问的问题基本就可以避免啦。Swift 只是强制程序员去主动思考了而已，原来是被动的，现在是把这个过程提前到代码编写阶段，不得不去考虑。</p>
<h2 id="可选型的实质"><a href="#可选型的实质" class="headerlink" title="可选型的实质"></a>可选型的实质</h2><p>可选型事实上是一个枚举，<code>String?</code> 实际上是 <code>Optional&lt;String&gt;</code>，它只是一个语法糖。下面两句代码是完全等价的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> optionalString: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> <span class="type">Optional</span>.some(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>而通常我们的解包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> aString <span class="operator">=</span> optionalString &#123;</span><br><span class="line">    aString <span class="comment">// 解包</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也可以看作下面的过程</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> optionalString &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .some(alString):</span><br><span class="line">    alString <span class="comment">// 这里就是解包后的 String 类型变量</span></span><br><span class="line"><span class="keyword">case</span> .none:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;none&quot;</span>) <span class="comment">// 这就是解包失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以尝试自己写一个这样的枚举</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyOptional</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> optionaString <span class="operator">=</span> <span class="type">MyOptional</span>.some(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// 这里类型是通过类型推断得到的，当然也可以显式声明其类型 MyOptional&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> optionaString &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .some(aString):</span><br><span class="line">    <span class="built_in">print</span>(aString) <span class="comment">// 这里就相当于解包成功咯</span></span><br><span class="line"><span class="keyword">case</span> .none:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;none&quot;</span>) <span class="comment">// 这里就是解包失败，也就是 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a>Optional Chaining</h2><p>我们知道可选型无法直接使用，那么我们就要先解包，然后使用，如果调用一个方法后返回类型还是可选型呢？那么我们再解包，再使用。那这样也太麻烦了吧？</p>
<p>所以呢，Swift 的这样一个语法就是解决这样的问题的，那就是 Optional Chaining，它的语法大约是下面这样的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">let</span> des <span class="operator">=</span> aString<span class="operator">?</span>.first<span class="operator">?</span>.description</span><br></pre></td></tr></table></figure>

<p>一个可选型可以直接调用它对应的非可选型的方法，只不过返回值同样变成了一个可选型而已（即使这个方法的返回类型是一个非可选型），我们知道 description 的返回类型是 String 类型，可是此时 des 的类型是 String？</p>
<h2 id="隐式可选型"><a href="#隐式可选型" class="headerlink" title="隐式可选型"></a>隐式可选型</h2><p>在 UIKit 中，有很多类型是如 <code>UIView!</code> 这样的，比如 UIViewController 中的 view 属性，这就是隐式可选型。</p>
<p>隐式可选型是什么呢？其实也是一个可选型，也就是说 <code>Int!</code> 和 <code>Int?</code>  都是可选型，都可以为 nil；那么区别在哪呢？区别很小，就是 <code>Int!</code> 可以省去解包这个步骤直接使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="type">Int</span>! <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> num <span class="operator">+</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>所以很简单，<code>Int!</code> 就是把强制解包的步骤给提前做啦，其他跟一般的可选型没啥区别；当然，这样肯定是有风险的，因为是强制解包嘛。所以程序员声明隐式可选型闭包保证一点，就是在真正使用它的时候，其必须不为 nil。</p>
<p>那隐式可选型有什么作用呢？目前来讲，其应用场景基本就是在定义类的时候，类的某些属性我们可以定义成隐式可选型。下面这个例子来自慕课网刘宇波老师的案例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cityName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">var</span> country: <span class="type">Country</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">cityName</span>: <span class="type">String</span>, <span class="params">country</span>: <span class="type">Country</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.cityName <span class="operator">=</span> cityName</span><br><span class="line">        <span class="keyword">self</span>.country <span class="operator">=</span> country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> countryName: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 这里如果不使用可选型,因为类的所有成员变量还没有被全部赋值,下面就无法在构造函数中使用 self,但是程序员又可以保证这个类的对象一旦创建,这个属性一定不为nil,所以这里使用了隐式可选型</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">countryName</span>: <span class="type">String</span>, <span class="params">capitalCity</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.countryName <span class="operator">=</span> countryName</span><br><span class="line">        <span class="keyword">self</span>.capitalCity <span class="operator">=</span> <span class="type">City</span>(cityName: capitalCity, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中， <code>Country</code> 类中的 <code>capitalCity</code> 属性被定义成了隐式可选型。</p>
<p>首先，为什么不能定义成一般的可选型呢？因为一个国家的首都都是确定存在的不可能为空啊，程序员其实不想把它定义成可选型，更不希望用户使用的时候还要解包。</p>
<p>那么就定义成非可选型呗？也不行，因为在构造函数里，我们在给 <code>self.capitalCity</code> 赋值的时候使用了 <code>self</code>，我们知道一个类的对象在构造完成前（因为 self.capitalCity 属性没有被赋值嘛）是不可以被使用的，那这怎么办呢？既然要用这个对象就要赋值，既然要赋值就要用这个对象，死循环了。</p>
<p>所以解决办法就是在赋值之前就让这个对象先构造完成，也就是把这个属性改成可选型，这样可选型可以不用初始化（默认为 nil），之后呢我们马上再给这个对象的这个属性赋上值，最终在用户使用这个对象的时候，这个属性可以保证不为 nil，同时用户也不用解包即可直接使用了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qiweipeng.github.io/2017/06/12/swift-security-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="齐卫鹏">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="齐卫鹏的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/12/swift-security-tips/" class="post-title-link" itemprop="url">从一些细节谈谈为什么说 Swift 是一门更安全的语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-12 20:03:46" itemprop="dateCreated datePublished" datetime="2017-06-12T20:03:46+08:00">2017-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-26 15:58:51" itemprop="dateModified" datetime="2024-11-26T15:58:51+08:00">2024-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习 Swift 的过程中，发现这门新语言在设计上确实融入了很多思考，Swift 宣称相对 Objective-C 是一门更安全的语言，那么本文就从语法设计上，举几个小例子谈谈 Swift 为了安全都做了哪些努力。</p>
<h2 id="Swift-中不允许溢出错误"><a href="#Swift-中不允许溢出错误" class="headerlink" title="Swift 中不允许溢出错误"></a>Swift 中不允许溢出错误</h2><p>在 Objective-C 中，如下代码会警告但是可以编译通过，打印结果为 -128，理解进制的就会知道，因为发生了溢出（int8_t 只能保存 -128 到 127 的整数），127 在二进制层面加 1 的结果就是 -128。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int8_t aInt8 = <span class="number">128</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, aInt8); <span class="comment">// -128</span></span><br></pre></td></tr></table></figure>

<p>溢出在 C 语言以及 Objective-C 中都是被允许的，但是潜在的 Bug 也会因此产生，大部分开发中我们其实更希望这种情况被及时提醒而不是编译通过，最终给我们一个莫名其妙的值。这种 Bug 往往也难以寻找。</p>
<p>而在 Swift 中，溢出是在语法检查的时候就无法编译通过的，如下面代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aInt8: <span class="type">Int8</span> <span class="operator">=</span> <span class="number">128</span> <span class="comment">// 错误信息：Integer literal &#x27;128&#x27; overflows when stored into &#x27;Int8&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Swift-不提供隐式的类型转换"><a href="#Swift-不提供隐式的类型转换" class="headerlink" title="Swift 不提供隐式的类型转换"></a>Swift 不提供隐式的类型转换</h2><p>与 Objective-C 不同，Swift 是一门强类型语言，我们甚至无法给一个整型变量赋值一个小数，更别说像 Objective-C 那样任意指针指向任意对象了。但是我们不必在所有情况下显式声明变量类型，是因为 Swift 为我们提供了 <code>类型推断（Type Inference）</code>，如下面代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aDouble <span class="operator">=</span> <span class="number">1.5</span> <span class="comment">// 类型推断为 Double 类型</span></span><br></pre></td></tr></table></figure>

<p>但是在类型转换上，Swift 要求极为严格，一个 Int 类型绝对是无法和一个 Double 类型相加的，必须显式地类型转换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Double</span> <span class="operator">=</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须显式进行类型转换,避免潜在 Bug 出现</span></span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> <span class="type">Int</span>(x) <span class="operator">+</span> y</span><br></pre></td></tr></table></figure>

<h2 id="赋值运算取消返回值"><a href="#赋值运算取消返回值" class="headerlink" title="赋值运算取消返回值"></a>赋值运算取消返回值</h2><p>我们看下面代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *aString = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aString == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;aString is nil.&quot;</span>); <span class="comment">// 打印 aString is nil.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码本身没有意义，目的在于说明一个程序员可能发生的错误，这就是不小心把 <code>==</code> 写成了 <code>=</code>，结果会截然不同，但是 Bug 同样难以寻找。因此在有的 Objective-C 代码规范中会有这样的规定，建议上面代码中的 condition 部分写成 <code>nil == aString</code> 以避免类似 Bug 的发生。</p>
<p>而在 Swift 中，首先是没有非 0 即真的概念的（Swift 认为，0 应该是和其他整数一样的，不应该用它来表示空，因此发明了可选型），其次，赋值运算是没有返回值的，这样把它放在 if 语句中就直接会报错。</p>
<h2 id="for-in、if-else、switch-等语句中的大括号不可省略"><a href="#for-in、if-else、switch-等语句中的大括号不可省略" class="headerlink" title="for-in、if-else、switch 等语句中的大括号不可省略"></a>for-in、if-else、switch 等语句中的大括号不可省略</h2><p>记得听过一个故事，苹果的一位程序员因为 if 语句只有一句代码所以没有加大括号，后期添加代码时仍然忘记添加，因此导致 Bug。Swift 中所有这些语句均必须添加大括号。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本文只是从一些小细节入手去谈 Swift 的安全性，其更多地安全性的表现应该是<code>强类型</code>、<code>可选型</code>等等，这些内容值得单独去讲，之后会专门写文章去理解相关的概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">齐卫鹏</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">齐卫鹏</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
